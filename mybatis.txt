 增强的 JDBC  操纵数据库
	三层架构 ：界面层      业务逻辑层 	 数据访问层
	
	界面层  接受用户的数据	显示处理结果	（controller 包）
	业务逻辑层   处理业务逻辑  接受 界面层传来的数据	 计算逻辑 调用数据库 获取数据（service 包）
	数据访问层	完成对数据库的 增删 改查	（Dao类）
	
	类的交互
	用户使用界面层  -->业务逻辑层 -->数据访问层 （持久层 ）-->数据库(mysql)

	三层 处理的框架
	界面层 --servlet---springmvc
	业务逻辑层 --service类 --spring
	数据访问层 --dao类 --mybatis  

2.框架
	框架 规定好了 规则  将 我写出来的代码 识别 并且 排版成功
	1) sql  mapper ：sql映射
		可以吧表中的一行数据 映射为 一个java对象，操作这个对象 就相当于操作表中的数据
	2）Data Access Objects （DAOs） ：数据访问，对数据 进行 增删改查

mybatis 提供 功能：
	1.创建 Connuection ，Statement ,Resultset的能力 不用 开发人员创建对象
	2.提供 执行sql语句的能力
	3. 提供循环 ，吧sql的结果转化为java对象 List集合的能力
	4.提供 关闭资源的能力  不用手动关闭 Connuection Statement 
	5.开发人员做的事 ：提供 sql语句

实现步骤：
1.新建student表
2.加入maven的mybatis 坐标 ，mysql驱动坐标
3.创建实体类  Student --保存表中的一行数据
	加入依赖
4.创建持久层的dao接口 ，定义操作数据库的方法
5. 创建一个mybatis的 配置文件   sql映射文件  一个表一个 sql 映射文件   文件为xml
	5.1）在接口所在的目录中，
	5.2）文件名和接口保持一致

6.创建 mybatis的主配置文件 ：
	一个项目就一个主配置文件
	主配置文件 提供 数据库的连接信息 和 sql映射文件的 位置信息
7.创建使用mbatis类
 	通过mybatis 访问数据库
 过程  ：开发人员 提供 sql语句 --mybatis 处理sql  --开发人员得到List集合 或者java对象 （表中的数据）




过程细节：
	1.加入依赖 mybatis 依赖 和 mysql驱动
	2.定义一个 接口    接口内方法 返回 要查询的 表的信息 
		2.2  写一个同名的 xml     
			2.2.1   namespace	为接口的全限定名称  相对路径 绝对路径
			2.2.2  在 mapper 中 放 数据库操作 对应的标签   
				2.2.2.1   标签中对应的 id 代表 要执行的sql语句
				2.2.2.2   resultType 表示 sql 语句执行后  获得 的数据转换成 什么类型  将同名的列 给 相对于的 类型之中的数据
	3. 主配置文件  中 type =“POOLED”  POOLED 代表连接池信息
		3.1 pooled 之中的 property  之间的属性 
			分别代表 数据库中的 类的信息 和 连接池的信息  要操作的数据库的用户名和 密码
		3.2 主配置文件之中 用
			<mappers> 	来指定一个文件的位置
				resource =“”代表指定的文件的位置 
					      从类路径的路径信息开始
			napper  一次只能指定一个 文件

	4.查询 是 sqlSession.selectList(new SqlSession); 方法
	  插入  是 sqlSession.insert(new SqlSession   , 要插入的对象);

（2）	配置日志功能
	<settings>
		<setting name ="logImpl" value ="STDOUT_LOGGING"  />
	</settings>   
	放入主配置文件即可

第二章 类的介绍：
	1）Resources ：mybatis的 一个类 负责读主配置文件
	InputStream in =Resoruces.getResourceAsStream("mybatis.xml");
	2）SqlSessionFactoryBuilder ：创建SqlSessionFactory对象：
     	 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
	创建SqlSessionFactory对象
      	 SqlSessionFactory factory- = builder.build(in);
	3） SqlSessionFactory ：重量级对象 ，耗时长  整个项目只有一个
	SqlSessionFactory ：接口 接口实现类： DefaultSqlSessionFactory
	SqlSessionFactory 作用: 获取SqlSession 对象 SqlSession sqlSession = factory.openSession();
	openSession 方法说明：
	1. 无参 获取非自动提交事务的 SqlSession对象
	2. openSession （boolean ）：. openSession （true） 获取自动提交事务的SqlSession
				openSession （false） 非自动提交事务的SqlSession
	4）SqlSession：
	SqlSession：接口 定义了 操作数据的方法 ：例如 selectOne（）
	使用要求： SqlSession对象 不是线程安全的 需要在方法内部使用 ，在执行sql语句之前 ，使用openSession()获取 SqlSession
	执行sql后 需要关闭  执行 SqlSession。close（） 保证使用是线程安全的


	对于实现Dao接口后 如何解耦：
		StudentDao dao =new StudentDaoImpl（）；
		调用之后   dao对象 类型是 StudentDao  	路径为 namespace
	方法名称 就是 mapper文件中的 id值
	
	通过方法的返回值就可以确定MyBatis调用的是SqlSession中的方法
		如果返回值是 List 调用的就是selectList（）
		如果返回的是int 或者非List  看mapper 文件中的标签  就会调用 insert   ， uodate 等方法


	mybatis的 动态代理：mybatis 根据dao的方法调用 获取 sql语句的信息
		mybatis 根据dao 接口 创建出接口的实现类  and 对象
		完成SqlSession调用方法，访问数据库

第三章：
	1.动态代理： 使用SqlSession.getMapper（dao 接口 .class） 获取这个dao接口的对象
	2.传入参数： 从java代码中把数据传入到mapper文件的sql语句中。
		2.1）parameterType  :  写在mapper文件中的   一个属性  。表示dao接口中方法的参数的 数据类型	（指明一个简单类型的参数）
			例如：StudentDao接口
			public 	Student 	SelectStudentById（Integer  	id）
				如何让限制Dao接口的 xml 知道 传入的 是 Integer 类型的对象
				在xml中的 对于	<select>    语句中   加上 parameterType ="对应类型的   在java包中的 全限定名称"	 或者是mybatis定义的别名
					数据类型在 mybatis 中的别名 在 mybatis对于官方文档的第十五页有  对应表
				在mapper文件中获取简单了下的一个参数值： 使用#{ 任意字符 }

			使用#{ }之后 	mybatis执行sql是使用的jdbc中的PrepareStatument对象
				mybatis：执行下列代码：
				  1.mybatis 创建Connection  ，	PreparedStatement对象
				     String sql ="select id,name,email, age,for student where id =?";
				     preparedStatement pst =con.preparedStatement( sql );
				    pst.setInt (1,1001);

				2.执行sql封装为  resuletType="sql 语句中的 对于的 返回对象的类型的   绝对路径"
				  ResultSet  rs =ps.executeQuery();
				  while(rs.next()){
				//从数据库获取表的一行数据  存在  相对的 java对象属性中
				}
				return  对象; 	//给了 对于的 方法调用的返回值
		2.2）多个参数 ：使用@Param命名参数
			接口 public List <Student>  selectMulitParam(@Param ("myname")  String name , @Param ( "myage" ) Integer age )
			使用@Param（“参数名”）	String name
			   例如：
			     select * from student where name=#{myname}  or age= #{myage}  //		#{中为 注释内的 对于字符串}
		2.3）用对象 来传递 参数	，使用java对象的属性值 ，作为参数实际值
			使用对象语法： #{属性名 ，javaType =类型名称 ，jdbcType=数据类型} 很少用
			javaType：指java中的属性数据类型
			jdbcType：在数据库中的数据类型
			      :    #{paramName, javaType = "全限定名称（绝对路径）" , jdbcType =“mybatis中的 定义的 可查的 数据库类型的名字” }
			例如： #{paramName, javaType =java.lang.String, jdbcType =VARCHAR }
		    简化方式 （常用）：
			#{属性名}	,javaType ,jdbcType的值mybatis  反射获取  不要提供 
		2.4）按位置传值 :
			 public List <Student>  selectStudent( String name , Integer age );
				//mybatis  3.4 之前   使用 #{0}  , #{1}
				mybatis 3.4 之后 使用#{arg0}  ,#{arg1}
			一样  是 name = #{ arg0}     age = # { arg1 }
		2.5) 使用 Map 存放多个值
			 public List <Student>  selectStudent(Map<String , Object> map );   	//常用
			
		      Map<String ,Object >date =new HashMap<>();
		     date.put ("myname",张三)
		     date .put ("age" ,28)
			select 中：
				name =#{myname}	age=#{age}	myname  ,age 分别为 Map 中的 key

	3. # 和 $ 的区别
		# ：占位符： 告诉mybatis 使用实际的参数值代替 。 并使用PrepareStatement 对象执行sql语句  ，#{...} 代替 sql语句中的 "?" 这样做更安全 更迅速
			执行效率高   避免sql 注入	安全性更高	（代表的是值）
		$ :  字符串的连接 和替换   不是使用问号 来代替    使用 字符串的连接 和替换		使用的是id ="" =“传入的值”
			使用的是Statement 对象执行sql  ，效率比PreparedStatement 低
			#使用的是 预编译的操作对象   $ 可以sql注入
		
			