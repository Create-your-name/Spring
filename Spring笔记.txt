Spring：解决企业开发的难度 减轻项目模块之间的管理 类与类之间的管理 
核心技术 ioc aop  实现模块.类之间的耦合度 让关系更加松散

依赖：类A中使用了类B的属性或方法 叫做 类A  依赖 类B
maven 管理jar包 管理模块管理 资源内容
spring 管理项目之中方法
--------------------------------------------------------------------------------
Spring 第一个核心功能 IOC： 控制反转  描述的是 将对象的创建，赋值，管理工作都交给代码之外的容器实现 

控制：创建对象 对象之间的属性赋值 对象之间的关系管理
反转：把原来开发人员管理，将创建对象权限转移给代码之外容器实现，由容器来管理对象，创建对象，给属性赋值
正转：开发人员在代码中用new构造对象 开发人员主动管理对象
	Student student=new Student
容器： 存放对象 根据需求在容器内获取对象

使用IOC的理由：减少对代码的改动 实现不同的功能。解耦合！！·

JAVA中创建对象的方式：
1。构造方法
2.反射
3.序列化
4.克隆
5.IOC : 容器创建对象
IOC的体现：
	serlvet 1：类继承HttpServelt
	           2：在web.xml注册servlet ，<servelet -name> myservlet <servelet -name>
				<servelt-class>com.bjpwernode.controller.Myservlet<servelt-class>
		3.没有创建Servlet对象 没有Myservlet myservlet=new MyServlet
		4.Servlet 是Tomcat 创建的  Tomcat就称为容器  里面由Servlet对象
IOC 的技术实现，
  DI 是 ioc的技术实现，  ：依赖注入，只需要在程序中提供要使用的对象的名称就可以，
Spring 使用DI实现IOC功能，
-------------------------------------------------------------------------
Spring的IOC 由spring创建对象
实现步骤：
1.创建maven项目 
2.加入maven依赖
  spring的依赖
  junit依赖
3. 创建类 （普通类）♥♥
4.创建spring需要使用的配置文件※※♥♥♥♥
  声明类的信息，这些类由spring创建和管理
5.测试spring创建的对象。

ApplicationContext 容器名=new classPathApplicationContext(文件名);  容器读取该文件 // 创建对象
当遇见 bean标签时 通过反射机制 调用类的构造方法 创建对象 bean id 就是对象id 将对象 放在map之中
一个bean 只能创建一个对象 ，在读取文件的同时 对象就已经创建好了
在创建容器时 会创建配置文件的所有对象

 Someservice service = (Someservice) ac.getBean("someService");
从容器中的Map获取 someService 对象 拿到对象 赋值给service 用service 调用方法即可    

Spring 默认调用的时无参构造方法


Spring 配置名称 在项目中 默认 ApplicationContent

DI-XML //给JAVA对象的属性赋值
DI : 依赖注入，表示创建对象 给属性赋值。
DI的实现的语法由两种：
1.在spring的配置文件中使用 标签和 属性完成
2.使用 spring中的注解 完成属性的赋值  基于注解的DI实现

DI的语法分类：
（1.)set注入（设置注入）： 用类的set 方法 完成属性赋值。
	对于<property name="name" value="" />注入set方法  即是若有对应的set方法即可 实现  value 必须是字符串类型  所有值必须放在引号中 xml规则
	1.set注入 （设置注入）：spring调用类的set方法， 你可以在set方法中完成属性赋值
         		1.1简单类型的set注入
                	<bean id="" class=""
               		 <property name="属性名字" value="属性值"/>
                	一个property 只能给一个属性赋值
                	</bean> 
		
		1.2引用类型的set注入：spring调用类的set方法
		<bean id="" class=""
               		 <property name="属性名字" ref="属性值"/>
                	一个property 只能给一个属性赋值
                	</bean> 
	2.构造注入 ，spring调用类的有参构造方法 ，创建对象 完成赋值。 
		构造注入使用<constructor-arg>标签
		<constructor -arg>标签属性：
			name:表示构造方法的形参名
			index:表示构造方法的  中形参的位置 ，参数从左往右位置是0 1 2
			value:表示构造方法的形参是简单类型 使用value
			ref：表示构造方法的形参是引用类型 使用ref
	<property> 使用方式是 调用set对象
	<property> 使用方式是 调用set对象 一种是 index 默认 形参构造方法 在xml中创建spring对象  另一种是 name=""指定名字 创建对象
	另一种是 name=""指定名字 创建对象  另一种是 name=""指定名字 创建对象

		 引用类型的自动注入：spring框架根据某些规则 可以对引用类型赋值。不用手动赋值
           	             规则： byname  bytype
                	        1.byname （按名称注入）：Java类中引用类型的属性名 和spring容器中 （配置文件）（bean）的id名称一样 且数据类型一直
                                	                这样的容器中的bean ，spring能够赋值给引用类型
                        		<bean id="xx" class="yy" autowire ="byname">
                                       	简单类型属性赋值
                                       	</bean>
			即 在创建容器MAP过程中 构造类CLASS时 先进行简单类型属性赋值  
			后 编译器扫描到autowire 自动取得在类中的引用数据类型  与xml文件中bean =“id”一一对应 后注入
		2.bytype(按类型注入)： Java类中引用类型的数据类型 和spring容器中（配置文件）《bean》的class属性
                	                                时同源关系的 这样bean能够赋值给引用类型
                              		同源时一类的意思：
                          ·		    1.java类中 引用数据类型和bean的 class值时一样的
                              		2.java类中 引用数据类型和bean的 class值父子类关系
                         	     3.java类中 引用数据类型和bean class 的值的接口和实现类关系的
               			         语法：
              		           <bean id="xx" class="yy" autowire ="bytype">
                	                       简单类型属性赋值
                	                       </bean>
			即 在创建容器MAP过程中 构造类CLASS时 先进行简单类型属性赋值  
			后 编译器扫描到autowire=”bytype“ 自动取得在类中的引用数据类型  
			与xml文件中bean =class的一一对应 看看是否由三个对应关系的一种 有就相互对应
--------------------------------------------------------------------------------------------------------------------------
		1. 多个配置文件的优势
		 1.1每个文件 的大小笔记小 效率高
		 1.2 避免多人竞争 带来的冲突
		项目内有多个模块 一般采用 一个模块一个配置文件
		主文件 ：包含其他配置文件  著配置文件 不定义对象 
		           语法：<import resource="classpath：其他配置文件的路径"/>
		           关键字:"classpath:"表示类的路径 （class文件所在的目录）
			在spring配置文件中要指定其他文件的路径 需要使用classpath 告诉spring去哪里加载读取文件
	                	    <import resource="classpath:id-*"/>	//表示该id下所有的id开头的xml所有文件
				注意：主的配置文件名称不能包含在通配符的范围内 要不然会进入到无限循环 
（2.）基于注解的DI  通过注解 完成java对象的创建 属性赋值
	使用注解的步骤：
	1.加入maven的依赖 spring-context ，在你加入spring-context的同时 间接加入spring-aop的依赖  使用注解必须加入spring-aop依赖
	2.在类中加入spring的注解 （多个不同功能的注解）
	3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在你的项目中的位置
        学习的注解：
        1.@Component
        2.@Respotory
        3.@Service
        4.@Controller
        5.@value
        6.@Autowired
        7.@Resource
	通过spring的注解完成java对象的创建 配置 属性 代替xml文件
	实现步骤：
	1.加入依赖
	2。创建类 ，类中加入注解
	3.创建spring的配置文件 
	   声明组件扫描器的标签 指明注解在你项目中的位置。
	4.使用注解创建对象，创建容器ApplicationContext
      1.@Component (value="对象名")
		在想要创建的类的 头上加上注解 然后 
		在xml中 加入<context:component-scan base-package="包名"/> //组件扫描器  然后扫描器就扫描到此行 即创建了对象
           		使用value属性 ，指定对象的名称     
		也可以Component（“对象名”）

		不指定对象名称 由spring提供默认名称   直接@Conponent  spring会创建一个默认对象  默认的对象名称为类名的首字母小写
	          spring中和@Component功能一致，创建对象的注解还有：
	          1.@Repository(用在持久层类上面)：放在dao的实现类上面 
		表示创建dao对象，dao对象能够直接访问数据库
	          2.@Service(放在业务层类的上面)：放在service的实现类上面
		创建service对象 ，service对象是做业务处理 可以有事务等功能的。 
	          3.@Controller(用在控制器上面 )：放在控制器（处理器）类的上面，创建控制器对象的
		控制器对象 能够接受用户提交的参数 显示请求的处理结果.
	            以上三个注解的使用语法和@Component一样的 都能够创建对象，但是这三个注解还有额外的功能。
      1.@Value (value="对象名")
		在想要创建的类的  所想要   赋值的变量的 头上加上注解 然后 
           		使用value属性 ，指定对象的名称     
		也可以Value（“对象名”）
		也可以在set方法上面放@Value
引用类型
     3.@Autowired：spring框架提供的注解 实现引用类型的赋值
	spring中通过注解给引用类型赋值，使用的是自动注入原理 支持byName ，byType
	@Autowired：默认使用的是 byType自动注入

 	属性：required 是一个boolean类型的，默认 为true
   	  required=true ：表示引用类型赋值失败 ，程序报错，并且终止执行。
   	   required=false:如果找到了Autowired的时候  就代表找到了 引用类型的对象 并且赋值 成功
    	   required=true  更好 会提前把程序中的错误报出来  检测是不是正确的   有利于快速找到问题所在
  	位置：1。在属性定义的上面，无需set方法，推荐使用
  	     2.在set方法上面
	一样在xml下创建bean对象    原类型@Conponnet
	@Resource：来自jdk的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值
   	        使用的也是自动注入原理 支持byName byType 默认的是byName
 	位置：1， 在属性定义的上面 无需set方法，推荐使用
   	    2，在set方法的上面
 	默认是byName 如果使用byName自动赋值失败  再使用byType
 	只需用byName的方式  需要增加一个属性name
 	name的值是bean的id（名称）

 	-------------------------------
	 使用byName方式
 	1.在属性上面加入@Autowired
	 2.在属性上面加入@Qualifier(Value="对象的名字。。。bean的id")：表示使用指定名称的bean完成赋值