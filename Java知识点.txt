assert 关键字 用于异常处理
enum 关键字 用于枚举
	
	即对基本数据而言  普通数据类型 就是变量保存的就是值
	    对引用数据类型而言  引用数据类型就是创建一个堆内存 然后变量在栈内存保存的是堆内存的地址
面向对象的设计 的特征：
	封装性： 内部操作对外部而言不可见 ，内部操作都不可直接使用
	继承性： 在已有结构的基础上继续进行功能的扩充；
	多态性：在继承性的基础上  按照多种形参的不同 函数进行不同的操作

	OOA:面向对象分析 
	OOD：面向对象设计
	OOP：面向对象编程

	堆内存：保存的是对象的具体信息  堆内存的开辟是通过new实现的
	栈内存：保存的是一块堆内存的地址  通过地址找到堆内存 然后找到具体的值 

	由于对于属性的 值 合理 所以一般要加入 封装属性  private 说明符  用get和 set方法来注入属性 后来在get 和set方法内部 对属性的值 考虑是否正常
构造方法：
	1.构造方法的名称必须与类名称保持一致
	2.构造方法没有返回值
		程序编译器 是根据方法体的结构 来定义方法的类型的   
		如果使用了void  那么构造器会将构造方法和 普通方法搞混 	构造方法是在类对象实例化的时候调用的  普通方法是在 类对象实例化之后调用的

	3. 构造方法在new 一个实例化对象时自动调用
    在JAVA程序中 所有类都有构造方法 如果没有写  那么会默认提供一个无参的构造方法
    如果 明确定义了一个 构造方法 那么 就不会有默认创建的无参构造方法
	在进行多个方法定义的时候 最好在按照 参数名的多少来定义
	如果 没有 对象名称的引用  那么   new peo（）；就直接创建一个匿名对象  会被垃圾回收机制 给回收
this 关键字 ：
	实现三类描述：
	   1.当前类中的属性： this属性
		在给类中属性赋值的时候 会存在 由于 { }的存在 使构造方法 或者 set方法的形参的作用域 覆盖了 本方法 的属性作用域
		使得 set 方法 和 构造方法 没办法正确的给 属性赋值 所以 用this 来强调是 本对象的参数   
		因此 在 编写的 程序代码时 如果 时访问 本类的属性 加上this 来强调
	    2.类中的方法：构造方法或者 普通方法
		普通方法没什么好说的 。。。
		构造方法 可以 按照 多类型参数的 重载构造方法时 用 this关键字 来调用 更少的参数的构造方法 以此 实现 减少代码的 重复
		   对于 构造方法的互相调用 需要注意
		      构造方法实例 调用构造方法的时候  this（）；必须放在 构造方法的首行
		       调用this 的时候 要注意 构造方法 的出口 不要照成死循环
	   3.描述当前对象：

   常在JAVA开发之中 用简单JAVA类作为一个重要的组成部分 简单java类 无处不在
    简单java类指的是 可以描述某一类信息的 程序类  在类中 没有 复杂的 逻辑操作  作为 信息存储的 没接
   对于简单java类的 结构 有：
	类名称 有 意义 可以描述某一类事务
	类中的 属性 必须 private 进行 封装  有 get 和 set方法
	 类中 可以提供构造方法   但是必须保留 无参构造方法
	类中 不允许 出现任何 输出 语句 所有内容 的获取必须 返回
 	[非必须 ]   提供 一个 获取 对象 详细信息的方法


static：	会在类第一次加载的时候执行，不用等到实例化之后
	主要用来定义 属性 和方法 	在属性定义之后u一般由堆内存 空间保存
	static 定义之后 此 属性 或者方法 便成为了 公共空间 的  并且 static 属性 定义的方法和属性  都可以由类名称直接调用
	static 虽然定义在 类之中 但是 并不受实例化对象 控制  ：意思是  就算没有 实例化对象 那么 也有 static 属性的变量
	即  公共信息存储的时候 用static  非static 必须在 实例化对象产生之后才可以使用 
       		static 方法  也是 可以直接由 类名称 直接调用  也可以在没有实例化对象的
		   static 方法 只允许 使用 static 方法 或者 属性
		   非static 方法 允许 调用 static 方法 和 属性
	 	     	原因： 所有 static 方法或者属性 都可以在 没有实例化对象的 时刻调用 
对于 代码块：
	分为普通 代码块 例如 if { }
	       构造块   例如  只有    {   } 每次创建一个新的实例对象时候  会先调用 构造块
	       静态块   例如   static {  }   静态块 最先执行 优先于主方法 并且 不管有多少个 实例化出现  只会执行一次  主要是 对静态变量 方法的 初始化

数组：
	动态初始化：  数据类型【】 数据名称 =new 数据类型 【长度】；  每一个数组的保存内容都是数据类型的 默认值
	
	静态初始化 ：数组类型 数组 名称 【】=new 数据类型 【 】 {数据1 ，数据2  }	    在数据定义的时候就设置好了 其中的内容
	
	对于数组的内存分析：
		数组 是引用数据类型  数组名内存储的是 数组的地址 一定要开辟了 内存空间后使用 	必须有实例化对象 才能够使用数组
	foreach 迭代循环：  //  容易避免 数组的下标越界异常的情况
		foreach的语法格式：				int data [] =new int {1,2,3}
		    for（数据类型  变量  ： 数组 | 集合）{  }		for (int temp : data) {  } 	//自动循环将data数组的每一个数给temp
			最大的特点是 自动将数组的每一个元素内容取出保存在变量里面  这样就避免用下标的方式来获取你 
	数组的自身类库：
		java.util.Arrays.sort (数组名称);  		//自动数组排序
		System.arraycopu（原数组，原数组开始点，目标数组，目标数组开始点，拷贝长度）			//数组拷贝
       方法可变参数：  public static int sum ( int  . . .  data){}  //即可变参数
		类 数组
		作用：  在程序类设计 或者 开发者 调用的时候 利用可变参数 避免了 数组的传递操作  ：本质还是 数组
		
	如果 在类设计的过程之中 发现类没有属性存在的意义 那么 定义的 方法 就没必要时 普通方法 因为 普通方法 需要 实例化对象的产生

	对象数组： 即为存储的是对象的数组
合成设计模式： 即面向对象   将遇见的实际问题 拆分成一个个更小的实体类 ，后再组装起来 成为
	在面向对象设计模式  步骤：
		1. 先配写实体类  写实体类之中的 基本数据类型的属性    ------
			根据结构关系进行对象的配置
		2.根据要求通过结构获取数据

String ： 并不算 数据类型 但是 由于JVM  可以让String和普通数据类型一样 可以直接赋值
	jdk 1.8 之前 String 保存的是char 数组   1.9之后 保存的是byte 数组 （字节数组）
	 String 类型  就是对 数组的 一种特殊包装
	String 可以直接赋值 也可以通过 构造方法赋值  public String (String str)；
	因为String 并不是一个数据类型 因此 在程序中被 “”包含的所有东西都是 String 的匿名对象 不存在 String 常量的概念
	String 函数：
		String 类型 并不能直接 用 == 来进行比较   原因在于  String 是一个数组 的栈空间 其实是指向不同堆空间的地址 虽然 堆空间存储的东西可能相同 但是 地址不同 所以无法比较
		因此 使用 equals（String str） 进行字符串比较
		equals 方法 可以回避 null 的判断

	String strA =“刘海”	String strB=“刘海”	strA==strB ==true
	 之所以true   在Java程序底层提供了一个专门的字符串池  即所有的字符串共享一个字符串池	
	所有的字符串 在池中没有寻找到 对于的内容 才回去开辟新的空间
	
	String str =new String （“mldn”）；分析过程：
	"mldn " 写出来的时候 已经开出来了 一个 匿名对象  new也会开辟一个新的 堆空间
	即在使用构造方法实例化String对象时不会自动保存到字符串池  会开辟一个新的 空间 来存放 内容
	 public String intern（）； 手动 入字符串池

	而对于String +=“ABC”  会重新创建一个匿名String 对象 指向的是"ABC" 然后str 本身保存的对象
	       也会在字符串池中 如果String +=  出现过多次的话 那么就会有 很多的垃圾空间
	即 不要频繁修改String内容
     String 的方法：
	public String  （char[] args）将字符数组 转换成字符串
	public String  （char[] args,int offset ,int count ）将部分字符数组 转换成字符串
	public char charAt(int index) 	获取指定索引位置的 字符
	public char[] toCharArray ( ) 	将字符串转换成字符数组

	public String  （byte[] args）将字符数组 转换成字符串
	public String  （byte[] args,int offset ,int count ）将部分字符数组 转换成字符串
	public byte[] getBytes();	将字符串转为字节数组
	public byte[] getBytes(String charsetName) throws UnsupportedEncodingException	 编码转换
	equalsIgnoreCase （String） 不区分大小写比较
	public int compareTo （String） 字符串的大小比较
	public int compareToIgnoreCase （String） 不区分大小写的字符串的大小比较
	pulic bollean bolean contains(String s)判断子字符串是否存在
	public int indexOF（String str） 从头查找指定字符串位置
	public int indexOF（String str,int fromIndex） 从指定位置查找指定字符串位置
	public int lastIndexOF(String str) 从后向前查找指定字符串位置
	public int lastIndexOF(String str,int fromIndex 从指定位置向后查找指定字符串位置
	public boolean startsWith(String str) 判断是否是以指定字符串开头
	public boolean startsWith(String str ,int a)由指定位置 开始判断是否以str开头
	pulic String replaceAll（String str ，String str2）String.replaceAll  将string中 所有的 str替换成str2
	public String【】 split （String str） 按照指定的字符串进行拆分
	public String【】 split （String str，int a） 按照指定的字符串进行拆分成指定个数
	public String substring（int beginIndex）从指定索引截取到结尾
	public String substring（int beginIndex，int a）从指定索引截取到结尾截取指定位置
	public static String format（各种类型， int ，） 转换成一个字符串
	public String concat（String str） 描述的是字符串的连接
	public String stim（） 去除左右的空格
	public String toUpperCase（） 转换成大写
继承：-
	继承的目的在于 子类可以重用父类的结构 可以作为功能的扩充
	在子类被创建的时候  实例化了子类对象 系统也会自动调用 父类的构造方法   即 子类构造方法的第一行 自带 super（）
	如果没有写 无参构造 那么 就得 指定 明确调用父类的 有参构造	super（）
      Java 中 不允许多重继承 只允许 多层继承 不允许 同时有多个 父类
	继承一旦发生了	 所有的操作都可以被子类使用了	子累会维持父类的现有功能。
      如果 子类不满意 父类的功能需求：则
	 就会发生 方法 覆盖： 保留已有的方法名称，然后进行覆写
			方法名称  参数 都一样 就叫覆写          	意义：优化父类方法
	如果想要 父类的方法 也可以 用super.方法 来执行
	public > default >private  
	在覆写之中 访问权限只能越来越大 不能越来越小  即 父类 方法为 public 子类方法 不可以为 private
	权限只能 越来越 松 不能越来越严格
final：  最后的方法 变量 类   不能被覆写和继承
	可以用final 来定义常量， 定义了之后 就不会在变化   常量定义 要求 ！！！全部大写 、

Annotation：  以注解 实现程序开发。 
		@Override    覆写	在明确有覆写的方法上 追加一个@Override
		@Deprecated  过期操作  在一个软件项目的开发过程中 有个方法 新版本 不适应  老版本需要有 则 使用 过期操作
		@SuppressWarings   压制警告  让警告信息不出现 不骚扰你QAQ

多态： 
	方法的多态性：
		方法的重载： 同一个方法名  根据传入的参数个数的不同   实现不同的功能
		方法的覆写：由于类的不同  实现不同的功能
	对象的多态性：父子实例之间的转换处理
		对象向上转型：  父类  父类实例 =子类实例   //自动完成转换    优势：可以对参数进行 统一的设计 更容易写出 多态性好的代码     接受和 返回参数的统一性
		对象乡下转型  子类 子类实例 =（子类） 父类实例  强制转换

instanceof ：
	判断某个实例是否是某个类的对象 通过instanceof语法来实现
使用单元测试
1.加入junit依赖
2.创建测试作用的类 .在src/text/java 目录中创建类
3.创建测试方法 
	3.1.public
	3.2 没有返回值 
	3.3 方法没有参数
	3.4 方法上面加入@Test